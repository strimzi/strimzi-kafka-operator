// Module included in the following module:
//
// con-oauth-config.adoc

[id='proc-oauth-authentication-broker-config-{context}']
= Configuring {oauth} support for Kafka brokers

This procedure describes how to configure Kafka brokers so that the broker listeners are enabled to use {oauth} authentication using an authorization server.

We advise use of {oauth} over an encrypted interface through configuration of TLS listeners.
Plain listeners are not recommended.

If the authorization server is using certificates signed by the trusted CA and matching the {oauth} server hostname, TLS connection works using the default settings.
Otherwise, you have two connection options for your listener configuration when delegating token validation to the authorization server:

* xref:example-1[Configuring fast local JWT token validation]
* xref:example-2[Configuring token validation using an introspection endpoint]

Configure the Kafka brokers using properties that support your chosen authorization server, and the type of authorization you are implementing.

.Before you start

For more information on the configuration of {oauth} authentication for Kafka broker listeners, see:

* xref:appendix_crds#type-KafkaListenerAuthenticationOAuth-reference[KafkaListenerAuthenticationOAuth schema reference]
* xref:assembly-configuring-kafka-broker-listeners-deployment-configuration-kafka[Kafka broker listeners]
* xref:assembly-kafka-authentication-and-authorization-deployment-configuration-kafka[Authentication and Authorization]

.Prerequisites

* {ProductName} and Kafka are running
* An {oauth} authorization server is deployed

.Procedure

. Update the Kafka broker configuration (`Kafka.spec.kafka`) of your `Kafka` resource in an editor.
+
[source,shell]
----
kubectl edit kafka my-cluster
----

. Configure the Kafka broker `listeners` configuration.
+
The configuration for each type of listener does not have to be the same, as they are independent.
+
The examples here show the configuration options as configured for external listeners.
+
--
[[example-1]]
.Example 1: Configuring fast local JWT token validation
[source,yaml,subs="+quotes,attributes"]
----
external:
  type: loadbalancer
  authentication:
    type: oauth <1>
    validIssuerUri: <__https://<auth-server-address>/auth/realms/external__> <2>
    jwksEndpointUri: <__https://<auth-server-address>/auth/realms/external/protocol/openid-connect/certs__> <3>
    userNameClaim: preferred_username <4>
    tlsTrustedCertificates: <5>
    - secretName: oauth-server-cert
      certificate: ca.crt
    disableTlsHostnameVerification: true <6>
    jwksExpirySeconds: 360 <7>
    jwksRefreshSeconds: 300 <8>
    enableECDSA: "true" <9>
----
<1> Listener type set to `oauth`.
<2> URI of the token issuer used for authentication.
<3> URI of the JWKS certificate endpoint used for local JWT validation.
<4> The token claim (or key) that contains the actual user name in the token. The user name is the _principal_ used to identify the user. The `userNameClaim` value will depend on the authentication flow and the authorization server used.
<5> (Optional) Trusted certificates for TLS connection to the authorization server.
<6> (Optional) Disable TLS hostname verification. Default is `false`.
<7> The duration the JWKs certificates are considered valid before they expire. Default is `360` seconds. If you specify a longer time, consider the risk of allowing access to revoked certificates.
<8> The period between refreshes of JWKs certificates. The interval must be at least 60 seconds shorter than the expiry interval. Default is `300` seconds.
<9> (Optional) If ECDSA is used for signing JWT tokens on authorization server, then this needs to be enabled. It installs additional crypto providers using BouncyCastle crypto library. Default is `false`.

[[example-2]]
.Example 2: Configuring token validation using an introspection endpoint
[source,yaml,subs="+quotes,attributes"]
----
external:
  type: loadbalancer
  authentication:
    type: oauth
    validIssuerUri: <__https://<auth-server-address>/auth/realms/external__>
    introspectionEndpointUri: <__https://<auth-server-address>/auth/realms/external/protocol/openid-connect/token/introspect__> <1>
    clientId: kafka-broker <2>
    clientSecret: <3>
      secretName: my-cluster-oauth
      key: clientSecret
    userNameClaim: preferred_username <4>
----
--
<1> URI of the token introspection endpoint.
<2> Client ID to identify the client.
<3> Client Secret and client ID is used for authentication.
<4> The token claim (or key) that contains the actual user name in the token. The user name is the _principal_ used to identify the user. The `userNameClaim` value will depend on the authorization server used.
+
Depending on how you apply {oauth} authentication, and the type of authorization server being used, add additional configuration settings:
+
[source,yaml,subs="+quotes,attributes"]
----
  # ...
  authentication:
    type: oauth
    # ...
    checkIssuer: false <1>
    fallbackUserNameClaim: __CLIENT-ID__ <2>
    fallbackUserNamePrefix: __CLIENT-ACCOUNT__ <3>
    validTokenType: bearer <4>
    userInfoEndpointUri: __https://AUTH-SERVER-ADDRESS/auth/realms/external/protocol/openid-connect/userinfo__ <5>
----
<1> If your authorization server does not provide an `iss` claim, it is not possible to perform an issuer check. In this situation, set `checkIssuer` to `false` and do not specify a `validIssuerUri`. Default is `true`.
<2> An authorization server may not provide a single attribute to identify both regular users and clients. A client authenticating in its own name might provide a `client_id`. But a user authenticating using a username and password, to obtain a refresh token or an access token, might provide a `username` attribute in addition to a `client_id`. Use this fallback option to specify the username claim (attribute) to use if a primary user id attribute is not available.
<3> In situations where `fallbackUserNameClaim` is applicable, it may also be necessary to prevent name collisions between the values of the username claim, and those of the fallback username claim. Consider a situation where a client called `producer` exists, but also a regular user called `producer` exists. In order to differentiate between the two, you can use this property to add a prefix to the user id of the client.
<4> (Only applicable when using `introspectionEndpointUri`) Depending on the authorization server you are using, the introspection endpoint may or may not return the `token_type` attribute, or it may contain different values. You can specify a valid token type value that the response from the introspection endpoint has to contain.
<5> (Only applicable when using `introspectionEndpointUri`) The authorization server may be configured or implemented in such a way to not provide any identifiable information in an introspection endpoint response. In order to obtain the user id, you can configure the URI of the `userinfo` endpoint as a fallback. The `userNameClaim`, `fallbackUserNameClaim`, and `fallbackUserNamePrefix` settings are applied to the response of `userinfo` endpoint.

. Save and exit the editor, then wait for rolling updates to complete.

. Check the update in the logs or by watching the pod state transitions:
+
[source,shell,subs="+quotes,attributes"]
----
kubectl logs -f ${POD_NAME} -c ${CONTAINER_NAME}
kubectl get po -w
----
+
The rolling update configures the brokers to use {oauth} authentication.

.What to do next

* xref:proc-oauth-client-config-{context}[Configure your Kafka clients to use {oauth}]
