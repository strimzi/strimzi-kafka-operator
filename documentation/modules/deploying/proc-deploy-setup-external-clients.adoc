// Module included in the following assemblies:
//
// deploying/assembly_deploy-verify.adoc
// getting-started.adoc

[id='setup-external-clients-{context}']
= Setting up access for clients outside of Kubernetes

This procedure shows how to configure client access to a Kafka cluster from outside Kubernetes.

Using the address of the Kafka cluster, you can provide external access to a client on a different Kubernetes namespace or outside Kubernetes entirely.

You configure an external Kafka listener to provide the access.

The following external listener types are supported:

* `route` to use OpenShift `Route` and the default HAProxy router
* `loadbalancer` to use loadbalancer services
* `nodeport` to use ports on Kubernetes nodes
* `ingress` to use Kubernetes _Ingress_ and the {NginxIngressController}

The type chosen depends on your requirements, and your environment and infrastructure.
For example, loadbalancers might not be suitable for certain infrastructure, such as bare metal, where node ports provide a better option.

In this procedure:

. An external listener is configured for the Kafka cluster, with TLS encryption and authentication, and Kafka _simple authorization_ is enabled.
. A `KafkaUser` is created for the client, with TLS authentication and Access Control Lists (ACLs) defined for _simple authorization_.

You can configure your listener to use TLS or SCRAM-SHA authentication,
both of which can be used with TLS encryption.
If you are using an authorization server, you can use token-based link:{BookURLUsing}#assembly-oauth-authentication_str[OAuth 2.0 authentication^] and link:{BookURLUsing}#assembly-oauth-authorization_str[OAuth 2.0 authorization^].

When you configure the `KafkaUser` authentication and authorization mechanisms, ensure they match the equivalent Kafka configuration:

* `KafkaUser.spec.authentication` matches `Kafka.spec.kafka.listeners.*.authentication`
* `KafkaUser.spec.authorization` matches `Kafka.spec.kafka.authorization`

You should have at least one listener supporting the authentication you want to use for the `KafkaUser`.

NOTE: Authentication between Kafka users and Kafka brokers depends on the authentication settings for each.
For example, it is not possible to authenticate a user with TLS if it is not also enabled in the Kafka configuration.

Strimzi operators automate the configuration process:

* The Cluster Operator creates the listeners and sets up the cluster and client certificate authority (CA) certificates to enable authentication within the Kafka cluster.
* The User Operator creates the user representing the client and the security credentials used for client authentication, based on the chosen authentication type.

In this procedure, the certificates generated by the Cluster Operator are used, but you can replace them by link:{BookURLUsing}#installing-your-own-ca-certificates-str[installing your own certificates^].
You can also configure your listener to link:{BookURLUsing}#kafka-listener-certificates-str[use a Kafka listener certificate managed by an external Certificate Authority^].

Certificates are available in PKCS #12 format (.p12) and PEM (.crt) formats.

.Prerequisites

* The Kafka cluster is available for the client
* The Cluster Operator and User Operator are running in the cluster
* A client outside the Kubernetes cluster to connect to the Kafka cluster

.Procedure

. Configure the Kafka cluster with an `external` Kafka listener.
+
* Define the authentication required to access the Kafka broker through the listener
* Enable authorization on the Kafka broker
+
For example:
+
[source,yaml,subs="+quotes,attributes"]
----
apiVersion: {KafkaApiVersion}
kind: Kafka
spec:
  kafka:
    # ...
    listeners: <1>
      external:
        type: _LISTENER-TYPE_ <2>
        tls: true <3>
        authentication:
          type: tls <4>
        configuration:
          preferredAddressType: InternalDNS <5>
        overrides: <6>
          # ...
      authorization: <7>
        type: simple
        superUsers:
          - super-user-name <8>
  # ...
----
<1> Configuration options for enabling external listeners are described in the link:{BookURLUsing}#type-KafkaListeners-reference[Kafka listeners schema reference^]
<2> External listener type specified as `route`, `loadbalancer`, `nodeport` or `ingress`.
<3> Enables TLS encryption on the listener. Not required for `route` listeners.
<4> Authentication specified as `tls`.
<5> (Optional, for `nodeport` listeners only) Configuration to link:{BookURLUsing}#type-NodePortListenerConfiguration-reference[specify a preference for the first address type used by Strimzi as the node address^].
<6> (Optional, but not applicable to `ingress` listeners) Overrides customize the bootstrap and broker addresses advertised to clients.
Strimzi automatically determines the addresses to advertise to clients.
The addresses are automatically assigned by Kubernetes.
Use overrides if the infrastructure on which you are running Strimzi does not provide the right address.
Validation is not performed on overrides.
The override configuration differs according to the external listener type,
so you can override hosts for `route`, DNS names or IP addresses for `loadbalancer`, and node ports (shown) for `nodeport`.
Refer to the link:{BookURLUsing}#type-KafkaListeners-reference[Kafka listeners schema reference^] for more information on external listener `overrides`.
<7> Authorization link:{BookURLUsing}#con-securing-kafka-authorization-str[enables `simple` authorization on the Kafka broker using the `AclAuthorizer` Kafka plugin^].
<8> (Optional) Super users can access all brokers regardless of any access restrictions defined in ACLs.

. Create or update the `Kafka` resource.
+
[source,shell,subs=+quotes]
kubectl apply -f _KAFKA-CONFIG-FILE_
+
The Kafka cluster is configured with a Kafka broker listener using TLS authentication.
+
A service is created for each Kafka broker pod.
+
A service is created to serve as the _bootstrap address_ for connection to the Kafka cluster.
+
A service is also created as the _external bootstrap address_ for external connection to the Kafka cluster using `nodeport` listeners.
+
The cluster CA certificate to verify the identity of the kafka brokers is also created with the same name as the `Kafka` resource.

. Find the bootstrap address and port from the status of the `Kafka` resource.
+
[source,shell, subs=+quotes]
kubectl get kafka _KAFKA-CLUSTER-NAME_ -o jsonpath='{.status.listeners[?(@.type=="external")].bootstrapServers}'
+
Use the bootstrap address in your Kafka client to connect to the Kafka cluster.

. Extract the public cluster CA certificate and password from the generated `_KAFKA-CLUSTER-NAME_-cluster-ca-cert` Secret.
+
[source,shell,subs="+quotes"]
kubectl get secret _KAFKA-CLUSTER-NAME_-cluster-ca-cert -o jsonpath='{.data.ca\.p12}' | base64 -d > ca.p12
+
[source,shell,subs="+quotes"]
kubectl get secret _KAFKA-CLUSTER-NAME_-cluster-ca-cert -o jsonpath='{.data.ca\.password}' | base64 -d > ca.password
+
Use the certificate and password in your Kafka client to connect to the Kafka cluster with TLS encryption.
+
NOTE: Cluster CA certificates renew automatically by default. If you are using your own Kafka listener certificates,
you will need to link:{BookURLUsing}#renewing-your-own-ca-certificates-str[renew the certificates manually^].

. Create or modify a user representing the client that requires access to the Kafka cluster.
+
* Specify the same authentication type as the `Kafka` listener.
* Specify the authorization ACLs for simple authorization.
+
For example:
+
[source,yaml,subs="+quotes,attributes"]
----
apiVersion: {KafkaUserApiVersion}
kind: KafkaUser
metadata:
  name: my-user
  labels:
    strimzi.io/cluster: my-cluster <1>
spec:
  authentication:
    type: tls <2>
  authorization:
    type: simple
    acls: <3>
      - resource:
          type: topic
          name: my-topic
          patternType: literal
        operation: Read
      - resource:
          type: topic
          name: my-topic
          patternType: literal
        operation: Describe
      - resource:
          type: group
          name: my-group
          patternType: literal
        operation: Read
----
<1> The label must match the label of the Kafka cluster for the user to be created.
<2> Authentication specified as `tls`.
<3> Simple authorization requires an accompanying list of ACL rules to apply to the user.
The rules define the operations allowed on Kafka resources based on the _username_ (`my-user`).

. Create or modify the `KafkaUser` resource.
+
[source,shell,subs="+quotes,attributes"]
kubectl apply -f _USER-CONFIG-FILE_
+
The user is created, as well as a Secret with the same name as the `KafkaUser` resource.
The Secret contains a private and public key for TLS client authentication.
+
For example:
+
[source,yaml,subs="+quotes,attributes"]
----
apiVersion: v1
kind: Secret
metadata:
  name: my-user
  labels:
    strimzi.io/kind: KafkaUser
    strimzi.io/cluster: my-cluster
type: Opaque
data:
  ca.crt: _PUBLIC-KEY-OF-THE-CLIENT-CA_
  user.crt: _USER-CERTIFICATE-CONTAINING-PUBLIC-KEY-OF-USER_
  user.key: _PRIVATE-KEY-OF-USER_
  user.p12: _P12-ARCHIVE-FILE-STORING-CERTIFICATES-AND-KEYS_
  user.password: _PASSWORD-PROTECTING-P12-ARCHIVE_
----

. Configure your client to connect to the Kafka cluster with the properties required to make a secure connection to the Kafka cluster.

.. Add the authentication details for the public cluster certificates:
+
[source,env,subs="+quotes,attributes"]
----
security.protocol: SSL <1>
ssl.truststore.location: _PATH-TO/ssl/keys/truststore_ <2>
ssl.truststore.password: _CLUSTER-CA-CERT-PASSWORD_ <3>
ssl.truststore.type=PKCS12 <4>
----
<1> Enables TLS encryption (with or without TLS client authentication).
<2> Specifies the truststore location where the certificates were imported.
<3> Specifies the password for accessing the truststore. This property can be omitted if it is not needed by the truststore.
<4> Identifies the truststore type.
+
NOTE: Use `security.protocol: SASL_SSL` when using SCRAM-SHA authentication over TLS.

.. Add the bootstrap address and port for connecting to the Kafka cluster:
+
[source,env,subs="+quotes,attributes"]
----
bootstrap.servers: _BOOTSTRAP-ADDRESS:PORT_
----

.. Add the authentication details for the public user certificates:
+
[source,env,subs="+quotes,attributes"]
----
ssl.keystore.location: _PATH-TO/ssl/keys/user1.keystore_ <1>
ssl.keystore.password: _USER-CERT-PASSWORD_ <2>
----
<1> Specifies the keystore location where the certificates were imported.
<2> Specifies the password for accessing the keystore. This property can be omitted if it is not needed by the keystore.
+
The public user certificate is signed by the client CA when it is created.
