name: "Performance Report Generator"
description: "Parses performance test results and generates a markdown summary for GitHub Actions"

inputs:
  performance-dir:
    description: "Path to the performance results directory"
    required: false
    default: "systemtest/target/performance"

outputs:
  summary:
    description: "Markdown summary of performance results"
    value: ${{ steps.generate_report.outputs.summary }}
  has-results:
    description: "Whether performance results were found"
    value: ${{ steps.generate_report.outputs.has_results }}
  timestamp:
    description: "Timestamp of the performance test run"
    value: ${{ steps.generate_report.outputs.timestamp }}

runs:
  using: "composite"
  steps:
    - name: Generate Performance Report
      id: generate_report
      uses: actions/github-script@v7
      env:
        PERF_DIR: ${{ inputs.performance-dir }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const perfDir = process.env.PERF_DIR || 'systemtest/target/performance';

          /**
           * Find the latest timestamped results directory
           */
          function findLatestResultsDir(baseDir) {
            if (!fs.existsSync(baseDir)) {
              core.warning(`Performance directory not found: ${baseDir}`);
              return null;
            }

            const entries = fs.readdirSync(baseDir, { withFileTypes: true });
            const timestampDirs = entries
              .filter(entry => entry.isDirectory())
              .map(entry => entry.name)
              .sort()
              .reverse();

            if (timestampDirs.length === 0) {
              core.warning(`No timestamp directories found in ${baseDir}`);
              return null;
            }

            return path.join(baseDir, timestampDirs[0]);
          }

          /**
           * Parse a results-table.txt file
           */
          function parseResultsTable(tableFile) {
            if (!fs.existsSync(tableFile)) {
              return null;
            }

            const content = fs.readFileSync(tableFile, 'utf8');
            const lines = content.trim().split('\n');

            if (lines.length === 0) {
              return null;
            }

            // Extract use case name from first line
            const useCase = lines[0].replace('Use Case: ', '').trim();

            // Find data lines (lines starting with |, excluding separator lines with +)
            const dataLines = lines.filter(line => line.startsWith('|') && !line.startsWith('+'));

            if (dataLines.length < 2) {
              return { useCase, experiments: [], rawTable: content };
            }

            // Parse header
            const header = dataLines[0].split('|')
              .slice(1, -1)
              .map(col => col.trim());

            // Parse experiment rows
            const experiments = [];
            for (let i = 1; i < dataLines.length; i++) {
              const values = dataLines[i].split('|')
                .slice(1, -1)
                .map(col => col.trim());

              if (values.length === header.length) {
                const experiment = {};
                header.forEach((h, idx) => {
                  experiment[h] = values[idx];
                });
                experiments.push(experiment);
              }
            }

            return {
              useCase,
              header,
              experiments,
              rawTable: content
            };
          }

          /**
           * Parse results for a specific operator
           */
          function parseOperatorResults(operatorDir) {
            if (!fs.existsSync(operatorDir)) {
              return null;
            }

            const resultsTablePath = path.join(operatorDir, 'results-table.txt');
            const operatorName = path.basename(operatorDir);

            return {
              operator: operatorName,
              resultsTable: parseResultsTable(resultsTablePath)
            };
          }

          /**
           * Format timestamp from directory name (yyyy-MM-dd-HH-mm-ss) to readable format
           */
          function formatTimestamp(timestamp) {
            // Parse format: 2025-11-07-17-39-26
            const parts = timestamp.split('-');
            if (parts.length === 6) {
              const [year, month, day, hour, minute] = parts;
              return `${year}-${month}-${day} ${hour}:${minute}`;
            }
            return timestamp;
          }

          /**
           * Generate markdown summary
           */
          function generateMarkdownSummary(results) {
            const lines = [
              `**Test Run:** \`${formatTimestamp(results.timestamp)}\``,
              ''
            ];

            for (const [operatorName, operatorData] of Object.entries(results.operators)) {
              if (!operatorData || !operatorData.resultsTable) {
                continue;
              }

              const title = operatorName.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
              lines.push(`## ${title}`);
              lines.push('');

              const tableData = operatorData.resultsTable;

              if (!tableData.experiments || tableData.experiments.length === 0) {
                lines.push('_No results available_');
                lines.push('');
                continue;
              }

              // Add the raw table (already contains use case header)
              lines.push(tableData.rawTable);
              lines.push('');
            }

            lines.push('---');
            lines.push('_Performance results generated automatically_');

            return lines.join('\n');
          }

          // Main execution
          try {
            const latestDir = findLatestResultsDir(perfDir);

            if (!latestDir) {
              core.setOutput('has_results', 'false');
              core.setOutput('summary', '_No performance results found_');
              core.setOutput('timestamp', '');
              return;
            }

            const timestamp = path.basename(latestDir);
            core.info(`Found performance results: ${timestamp}`);

            const results = {
              timestamp,
              operators: {}
            };

            // Parse topic-operator results
            const topicOpDir = path.join(latestDir, 'topic-operator');
            const topicOpResults = parseOperatorResults(topicOpDir);
            if (topicOpResults) {
              results.operators['topic-operator'] = topicOpResults;
            }

            // Parse user-operator results
            const userOpDir = path.join(latestDir, 'user-operator');
            const userOpResults = parseOperatorResults(userOpDir);
            if (userOpResults) {
              results.operators['user-operator'] = userOpResults;
            }

            const summary = generateMarkdownSummary(results);

            core.setOutput('has_results', 'true');
            core.setOutput('summary', summary);
            core.setOutput('timestamp', timestamp);

            core.info('Performance report generated successfully');

          } catch (error) {
            core.error(`Error generating performance report: ${error.message}`);
            core.setOutput('has_results', 'false');
            core.setOutput('summary', `_Error generating performance report: ${error.message}_`);
            core.setOutput('timestamp', '');
          }