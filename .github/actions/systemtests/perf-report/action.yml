name: "Performance Report Generator"
description: "Parses performance test results and generates a markdown summary for GitHub Actions"

inputs:
  performance-dir:
    description: "Path to the performance results directory"
    required: false
    default: "systemtest/target/performance"

outputs:
  summary:
    description: "Markdown summary of performance results"
    value: ${{ steps.generate_report.outputs.summary }}
  has-results:
    description: "Whether performance results were found"
    value: ${{ steps.generate_report.outputs.has_results }}
  timestamp:
    description: "Timestamp of the performance test run"
    value: ${{ steps.generate_report.outputs.timestamp }}

runs:
  using: "composite"
  steps:
    - name: Generate Performance Report
      id: generate_report
      uses: actions/github-script@v7
      env:
        PERF_DIR: ${{ inputs.performance-dir }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const perfDir = process.env.PERF_DIR || 'systemtest/target/performance';

          /**
           * Map agent name to architecture
           */
          function getArchFromAgent(agentName) {
            if (agentName.includes('arm')) {
              return 'arm64';
            }
            return 'amd64';
          }

          /**
           * Detect artifact directories (performance-results-*)
           */
          function findArtifactDirs(baseDir) {
            if (!fs.existsSync(baseDir)) {
              core.warning(`Performance directory not found: ${baseDir}`);
              return [];
            }

            const entries = fs.readdirSync(baseDir, { withFileTypes: true });
            const artifactDirs = entries
              .filter(entry => entry.isDirectory() && entry.name.startsWith('performance-results-'))
              .map(entry => ({
                name: entry.name,
                path: path.join(baseDir, entry.name),
                // Extract architecture from agent name in artifact name
                // e.g., performance-results-performance-performance-ubuntu-latest -> amd64
                // e.g., performance-results-performance-performance-ubuntu-24.04-arm -> arm64
                arch: getArchFromAgent(entry.name)
              }));

            return artifactDirs;
          }

          /**
           * Find the latest timestamped results directory
           */
          function findLatestResultsDir(baseDir) {
            if (!fs.existsSync(baseDir)) {
              core.warning(`Performance directory not found: ${baseDir}`);
              return null;
            }

            const entries = fs.readdirSync(baseDir, { withFileTypes: true });
            const timestampDirs = entries
              .filter(entry => entry.isDirectory())
              .map(entry => entry.name)
              .sort()
              .reverse();

            if (timestampDirs.length === 0) {
              core.warning(`No timestamp directories found in ${baseDir}`);
              return null;
            }

            return path.join(baseDir, timestampDirs[0]);
          }

          /**
           * Parse a results-table.txt file
           */
          function parseResultsTable(tableFile) {
            if (!fs.existsSync(tableFile)) {
              return null;
            }

            const content = fs.readFileSync(tableFile, 'utf8');
            const lines = content.trim().split('\n');

            if (lines.length === 0) {
              return null;
            }

            // Extract use case name from first line
            const useCase = lines[0].replace('Use Case: ', '').trim();

            // Find data lines (lines starting with |, excluding separator lines with +)
            const dataLines = lines.filter(line => line.startsWith('|') && !line.startsWith('+'));

            if (dataLines.length < 2) {
              return { useCase, experiments: [], rawTable: content };
            }

            // Parse header
            const header = dataLines[0].split('|')
              .slice(1, -1)
              .map(col => col.trim());

            // Parse experiment rows
            const experiments = [];
            for (let i = 1; i < dataLines.length; i++) {
              const values = dataLines[i].split('|')
                .slice(1, -1)
                .map(col => col.trim());

              if (values.length === header.length) {
                const experiment = {};
                header.forEach((h, idx) => {
                  experiment[h] = values[idx];
                });
                experiments.push(experiment);
              }
            }

            return {
              useCase,
              header,
              experiments,
              rawTable: content
            };
          }

          /**
           * Parse results for a specific operator
           */
          function parseOperatorResults(operatorDir) {
            if (!fs.existsSync(operatorDir)) {
              return null;
            }

            const resultsTablePath = path.join(operatorDir, 'results-table.txt');
            const operatorName = path.basename(operatorDir);

            return {
              operator: operatorName,
              resultsTable: parseResultsTable(resultsTablePath)
            };
          }

          /**
           * Format timestamp from directory name (yyyy-MM-dd-HH-mm-ss) to readable format
           */
          function formatTimestamp(timestamp) {
            // Parse format: 2025-11-07-17-39-26
            const parts = timestamp.split('-');
            if (parts.length === 6) {
              const [year, month, day, hour, minute] = parts;
              return `${year}-${month}-${day} ${hour}:${minute}`;
            }
            return timestamp;
          }

          /**
           * Generate markdown summary for multiple architectures
           */
          function generateMarkdownSummary(allResults) {
            const lines = [];

            // Get all unique timestamps and operators
            const timestamps = new Set();
            const allArchs = Object.keys(allResults);

            allArchs.forEach(arch => {
              if (allResults[arch].timestamp) {
                timestamps.add(allResults[arch].timestamp);
              }
            });

            if (timestamps.size > 0) {
              const timestamp = Array.from(timestamps)[0];
              lines.push(`**Test Run:** \`${formatTimestamp(timestamp)}\``);
              lines.push('');
            }

            // Group results by operator
            const operators = new Set();
            allArchs.forEach(arch => {
              Object.keys(allResults[arch].operators || {}).forEach(op => operators.add(op));
            });

            // Generate report for each operator
            for (const operatorName of operators) {
              const title = operatorName.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
              lines.push(`## ${title}`);
              lines.push('');

              // Show results for each architecture
              for (const arch of allArchs.sort()) {
                const operatorData = allResults[arch].operators?.[operatorName];

                lines.push(`### ${arch.toUpperCase()}`);
                lines.push('');

                if (!operatorData || !operatorData.resultsTable) {
                  lines.push('_No results available_');
                  lines.push('');
                  continue;
                }

                const tableData = operatorData.resultsTable;

                if (!tableData.experiments || tableData.experiments.length === 0) {
                  lines.push('_No results available_');
                  lines.push('');
                  continue;
                }

                // Add the raw table (already contains use case header)
                lines.push(tableData.rawTable);
                lines.push('');
              }
            }

            lines.push('---');
            lines.push('_Performance results generated automatically_');

            return lines.join('\n');
          }

          // Main execution
          try {
            // First, check if we have artifact directories (from separate downloads)
            const artifactDirs = findArtifactDirs(perfDir);

            let allResults = {};
            let hasResults = false;
            let commonTimestamp = '';

            if (artifactDirs.length > 0) {
              // Process each artifact directory (one per architecture)
              core.info(`Found ${artifactDirs.length} artifact directories`);

              for (const artifactDir of artifactDirs) {
                core.info(`Processing artifact: ${artifactDir.name} (${artifactDir.arch})`);

                const latestDir = findLatestResultsDir(artifactDir.path);
                if (!latestDir) {
                  core.warning(`No results found in ${artifactDir.name}`);
                  continue;
                }

                const timestamp = path.basename(latestDir);
                if (!commonTimestamp) {
                  commonTimestamp = timestamp;
                }

                const results = {
                  timestamp,
                  operators: {}
                };

                // Parse topic-operator results
                const topicOpDir = path.join(latestDir, 'topic-operator');
                const topicOpResults = parseOperatorResults(topicOpDir);
                if (topicOpResults) {
                  results.operators['topic-operator'] = topicOpResults;
                  hasResults = true;
                }

                // Parse user-operator results
                const userOpDir = path.join(latestDir, 'user-operator');
                const userOpResults = parseOperatorResults(userOpDir);
                if (userOpResults) {
                  results.operators['user-operator'] = userOpResults;
                  hasResults = true;
                }

                allResults[artifactDir.arch] = results;
              }
            } else {
              // Fallback to old behavior for backward compatibility (single directory)
              core.info('No artifact directories found, checking for direct results');
              const latestDir = findLatestResultsDir(perfDir);

              if (latestDir) {
                const timestamp = path.basename(latestDir);
                commonTimestamp = timestamp;
                core.info(`Found performance results: ${timestamp}`);

                const results = {
                  timestamp,
                  operators: {}
                };

                // Parse topic-operator results
                const topicOpDir = path.join(latestDir, 'topic-operator');
                const topicOpResults = parseOperatorResults(topicOpDir);
                if (topicOpResults) {
                  results.operators['topic-operator'] = topicOpResults;
                  hasResults = true;
                }

                // Parse user-operator results
                const userOpDir = path.join(latestDir, 'user-operator');
                const userOpResults = parseOperatorResults(userOpDir);
                if (userOpResults) {
                  results.operators['user-operator'] = userOpResults;
                  hasResults = true;
                }

                // Assume amd64 if not specified
                allResults['amd64'] = results;
              }
            }

            if (!hasResults) {
              core.setOutput('has_results', 'false');
              core.setOutput('summary', '_No performance results found_');
              core.setOutput('timestamp', '');
              return;
            }

            const summary = generateMarkdownSummary(allResults);

            core.setOutput('has_results', 'true');
            core.setOutput('summary', summary);
            core.setOutput('timestamp', commonTimestamp);

            core.info('Performance report generated successfully');

          } catch (error) {
            core.error(`Error generating performance report: ${error.message}`);
            core.setOutput('has_results', 'false');
            core.setOutput('summary', `_Error generating performance report: ${error.message}_`);
            core.setOutput('timestamp', '');
          }