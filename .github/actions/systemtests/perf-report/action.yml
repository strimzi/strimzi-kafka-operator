name: "Performance Report Generator"
description: "Parses performance test results and generates a markdown summary for GitHub Actions"

inputs:
  performance-dir:
    description: "Path to the performance results directory"
    required: false
    default: "systemtest/target/performance"

outputs:
  summary:
    description: "Markdown summary of performance results"
    value: ${{ steps.generate_report.outputs.summary }}
  has-results:
    description: "Whether performance results were found"
    value: ${{ steps.generate_report.outputs.has_results }}
  timestamp:
    description: "Timestamp of the performance test run"
    value: ${{ steps.generate_report.outputs.timestamp }}

runs:
  using: "composite"
  steps:
    - name: Generate Performance Report
      id: generate_report
      uses: actions/github-script@v7
      env:
        PERF_DIR: ${{ inputs.performance-dir }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const perfDir = process.env.PERF_DIR || 'systemtest/target/performance';

          /**
           * Map agent name to architecture
           */
          function getArchFromAgent(agentName) {
            if (agentName.includes('arm')) {
              return 'arm64';
            }
            return 'amd64';
          }

          /**
           * Detect artifact directories (performance-results-*)
           */
          function findArtifactDirs(baseDir) {
            if (!fs.existsSync(baseDir)) {
              core.warning(`Performance directory not found: ${baseDir}`);
              return [];
            }

            const entries = fs.readdirSync(baseDir, { withFileTypes: true });
            const artifactDirs = entries
              .filter(entry => entry.isDirectory() && entry.name.startsWith('performance-results-'))
              .map(entry => ({
                name: entry.name,
                path: path.join(baseDir, entry.name),
                // Extract architecture from agent name in artifact name
                // e.g., performance-results-performance-performance-ubuntu-latest -> amd64
                // e.g., performance-results-performance-performance-ubuntu-24.04-arm -> arm64
                arch: getArchFromAgent(entry.name)
              }));

            return artifactDirs;
          }

          /**
           * Find the latest timestamped results directory
           */
          function findLatestResultsDir(baseDir) {
            if (!fs.existsSync(baseDir)) {
              core.warning(`Performance directory not found: ${baseDir}`);
              return null;
            }

            const entries = fs.readdirSync(baseDir, { withFileTypes: true });
            const timestampDirs = entries
              .filter(entry => entry.isDirectory())
              .map(entry => entry.name)
              .sort()
              .reverse();

            if (timestampDirs.length === 0) {
              core.warning(`No timestamp directories found in ${baseDir}`);
              return null;
            }

            return path.join(baseDir, timestampDirs[0]);
          }

          /**
           * Parse a results-table.txt file that may contain multiple use cases
           */
          function parseResultsTable(tableFile) {
            if (!fs.existsSync(tableFile)) {
              return null;
            }

            const content = fs.readFileSync(tableFile, 'utf8');
            const lines = content.trim().split('\n');

            if (lines.length === 0) {
              return null;
            }

            // Find all use case sections
            const useCaseIndices = [];
            lines.forEach((line, idx) => {
              if (line.match(/^\*\*Use Case:\*\*/) || line.match(/^Use Case:/)) {
                useCaseIndices.push(idx);
              }
            });

            if (useCaseIndices.length === 0) {
              return null;
            }

            // Parse each use case section
            const useCases = [];
            for (let i = 0; i < useCaseIndices.length; i++) {
              const startIdx = useCaseIndices[i];
              const endIdx = i < useCaseIndices.length - 1 ? useCaseIndices[i + 1] : lines.length;
              const sectionLines = lines.slice(startIdx, endIdx);

              // Extract use case name
              const useCaseLine = sectionLines[0];
              const useCase = useCaseLine
                .replace(/^\*\*Use Case:\*\*/, '')
                .replace(/^Use Case:/, '')
                .trim();

              // Extract configuration and table sections
              const configStart = sectionLines.findIndex(line => line.match(/^\*\*Configuration:\*\*/));
              const resultsStart = sectionLines.findIndex(line => line.match(/^\*\*Results:\*\*/));

              let configLines = [];
              if (configStart >= 0 && resultsStart >= 0) {
                configLines = sectionLines.slice(configStart + 1, resultsStart)
                  .filter(line => line.trim() && !line.match(/^\*\*/))
                  .map(line => line.replace(/^- /, ''));
              }

              // Find table data
              const tableLines = resultsStart >= 0
                ? sectionLines.slice(resultsStart + 1)
                : sectionLines.slice(1);

              const dataLines = tableLines.filter(line =>
                line.startsWith('|') && !line.startsWith('|---')
              );

              if (dataLines.length < 2) {
                continue;
              }

              // Parse header
              const header = dataLines[0].split('|')
                .slice(1, -1)
                .map(col => col.trim());

              // Parse experiment rows
              const experiments = [];
              for (let j = 1; j < dataLines.length; j++) {
                const values = dataLines[j].split('|')
                  .slice(1, -1)
                  .map(col => col.trim());

                if (values.length === header.length) {
                  const experiment = {};
                  header.forEach((h, idx) => {
                    experiment[h] = values[idx];
                  });
                  experiments.push(experiment);
                }
              }

              // Build raw table for this use case
              const rawTableLines = [
                `Use Case: ${useCase}`,
                ...configLines,
                '',
                ...dataLines
              ];

              useCases.push({
                useCase,
                header,
                experiments,
                rawTable: rawTableLines.join('\n')
              });
            }

            return useCases;
          }

          /**
           * Parse results for a specific operator
           */
          function parseOperatorResults(operatorDir) {
            if (!fs.existsSync(operatorDir)) {
              return null;
            }

            const resultsTablePath = path.join(operatorDir, 'results-table.txt');
            const operatorName = path.basename(operatorDir);

            return {
              operator: operatorName,
              resultsTable: parseResultsTable(resultsTablePath)
            };
          }

          /**
           * Format timestamp from directory name (yyyy-MM-dd-HH-mm-ss) to readable format
           */
          function formatTimestamp(timestamp) {
            // Parse format: 2025-11-07-17-39-26
            const parts = timestamp.split('-');
            if (parts.length === 6) {
              const [year, month, day, hour, minute] = parts;
              return `${year}-${month}-${day} ${hour}:${minute}`;
            }
            return timestamp;
          }

          /**
           * Generate markdown summary for multiple architectures
           */
          function generateMarkdownSummary(allResults) {
            const lines = [];

            // Get all unique timestamps and operators
            const timestamps = new Set();
            const allArchs = Object.keys(allResults).sort();

            allArchs.forEach(arch => {
              if (allResults[arch].timestamp) {
                timestamps.add(allResults[arch].timestamp);
              }
            });

            if (timestamps.size > 0) {
              const timestamp = Array.from(timestamps)[0];
              lines.push(`**Test Run:** \`${formatTimestamp(timestamp)}\``);
              lines.push('');
            }

            // Group results by operator
            const operators = new Set();
            allArchs.forEach(arch => {
              Object.keys(allResults[arch].operators || {}).forEach(op => operators.add(op));
            });

            // Generate report for each operator
            for (const operatorName of operators) {
              const title = operatorName.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
              lines.push(`## ${title}`);
              lines.push('');

              // Group results by use case across architectures
              const useCases = new Map();

              for (const arch of allArchs) {
                const operatorData = allResults[arch].operators?.[operatorName];
                if (operatorData?.resultsTable) {
                  // resultsTable is now an array of use cases
                  const useCasesArray = Array.isArray(operatorData.resultsTable)
                    ? operatorData.resultsTable
                    : [operatorData.resultsTable];

                  useCasesArray.forEach(tableData => {
                    const useCase = tableData.useCase;
                    if (!useCases.has(useCase)) {
                      useCases.set(useCase, {});
                    }
                    useCases.get(useCase)[arch] = tableData;
                  });
                }
              }

              // Generate merged tables for each use case
              // Note: Only use cases that are actually present in the results will be processed
              for (const [useCase, archResults] of useCases) {
                lines.push(`**Use Case:** ${useCase}`);
                lines.push('');

                // Get configuration from first available architecture
                const firstArchData = Object.values(archResults)[0];
                if (firstArchData.rawTable) {
                  // Extract configuration lines (lines before the table starts)
                  const rawLines = firstArchData.rawTable.split('\n');
                  const configLines = [];
                  for (let i = 1; i < rawLines.length; i++) {
                    if (rawLines[i].startsWith('|')) break;
                    if (rawLines[i].trim()) {
                      configLines.push(rawLines[i]);
                    }
                  }
                  if (configLines.length > 0) {
                    lines.push('**Configuration:**');
                    configLines.forEach(line => lines.push(`- ${line}`));
                    lines.push('');
                  }
                }

                // Build merged table with architecture-specific columns
                const hasMultipleArchs = Object.keys(archResults).length > 1;
                lines.push('**Results:**');
                lines.push('');

                if (hasMultipleArchs) {
                  // Merge tables by combining metric columns
                  const archList = Object.keys(archResults).sort();
                  const tables = {};

                  // Parse all architecture tables
                  for (const arch of archList) {
                    const tableData = archResults[arch];
                    if (tableData.experiments && tableData.header) {
                      tables[arch] = {
                        header: tableData.header,
                        experiments: tableData.experiments
                      };
                    }
                  }

                  if (Object.keys(tables).length > 0) {
                    // Identify common columns (typically identifiers like #, NUMBER OF TOPICS, etc.)
                    // and metric columns (will have architecture suffix)
                    const firstArch = archList[0];
                    const baseHeader = tables[firstArch].header;

                    // Determine which columns are identifiers vs metrics
                    // Heuristic: columns with # or NUMBER in name are identifiers
                    const identifierCols = [];
                    const metricCols = [];

                    baseHeader.forEach(col => {
                      if (col.match(/^#$|NUMBER|Experiment/i)) {
                        identifierCols.push(col);
                      } else {
                        metricCols.push(col);
                      }
                    });

                    // Build merged header
                    const mergedHeader = [...identifierCols];
                    metricCols.forEach(metricCol => {
                      archList.forEach(arch => {
                        const archLabel = arch.toUpperCase();
                        mergedHeader.push(`${metricCol} [${archLabel}]`);
                      });
                    });

                    // Build merged rows
                    const mergedRows = [];
                    const firstArchExperiments = tables[firstArch].experiments;

                    for (let i = 0; i < firstArchExperiments.length; i++) {
                      const row = {};

                      // Copy identifier columns from first architecture
                      identifierCols.forEach(col => {
                        row[col] = firstArchExperiments[i][col] || '';
                      });

                      // Add metric columns for each architecture
                      metricCols.forEach(metricCol => {
                        archList.forEach(arch => {
                          const archLabel = arch.toUpperCase();
                          const archExp = tables[arch]?.experiments[i];
                          row[`${metricCol} [${archLabel}]`] = archExp?.[metricCol] || 'N/A';
                        });
                      });

                      mergedRows.push(row);
                    }

                    // Generate markdown table
                    const headerRow = '| ' + mergedHeader.join(' | ') + ' |';
                    const separatorRow = '|' + mergedHeader.map(() => '---').join('|') + '|';
                    lines.push(headerRow);
                    lines.push(separatorRow);

                    mergedRows.forEach(row => {
                      const values = mergedHeader.map(h => row[h] || '');
                      lines.push('| ' + values.join(' | ') + ' |');
                    });
                  }
                } else {
                  // Single architecture - show table as-is
                  const tableData = Object.values(archResults)[0];
                  if (tableData.rawTable) {
                    const rawLines = tableData.rawTable.split('\n');
                    const tableStart = rawLines.findIndex(line => line.startsWith('|'));
                    if (tableStart >= 0) {
                      lines.push(rawLines.slice(tableStart).join('\n'));
                    }
                  }
                }

                lines.push('');
              }

              if (useCases.size === 0) {
                lines.push('_No results available_');
                lines.push('');
              }
            }

            lines.push('---');
            lines.push('_Performance results generated automatically_');

            return lines.join('\n');
          }

          // Main execution
          try {
            // First, check if we have artifact directories (from separate downloads)
            const artifactDirs = findArtifactDirs(perfDir);

            let allResults = {};
            let hasResults = false;
            let commonTimestamp = '';

            if (artifactDirs.length > 0) {
              // Process each artifact directory (one per architecture)
              core.info(`Found ${artifactDirs.length} artifact directories`);

              for (const artifactDir of artifactDirs) {
                core.info(`Processing artifact: ${artifactDir.name} (${artifactDir.arch})`);

                const latestDir = findLatestResultsDir(artifactDir.path);
                if (!latestDir) {
                  core.warning(`No results found in ${artifactDir.name}`);
                  continue;
                }

                const timestamp = path.basename(latestDir);
                if (!commonTimestamp) {
                  commonTimestamp = timestamp;
                }

                const results = {
                  timestamp,
                  operators: {}
                };

                // Parse topic-operator results
                const topicOpDir = path.join(latestDir, 'topic-operator');
                const topicOpResults = parseOperatorResults(topicOpDir);
                if (topicOpResults) {
                  results.operators['topic-operator'] = topicOpResults;
                  hasResults = true;
                }

                // Parse user-operator results
                const userOpDir = path.join(latestDir, 'user-operator');
                const userOpResults = parseOperatorResults(userOpDir);
                if (userOpResults) {
                  results.operators['user-operator'] = userOpResults;
                  hasResults = true;
                }

                allResults[artifactDir.arch] = results;
              }
            } else {
              // Fallback to old behavior for backward compatibility (single directory)
              core.info('No artifact directories found, checking for direct results');
              const latestDir = findLatestResultsDir(perfDir);

              if (latestDir) {
                const timestamp = path.basename(latestDir);
                commonTimestamp = timestamp;
                core.info(`Found performance results: ${timestamp}`);

                const results = {
                  timestamp,
                  operators: {}
                };

                // Parse topic-operator results
                const topicOpDir = path.join(latestDir, 'topic-operator');
                const topicOpResults = parseOperatorResults(topicOpDir);
                if (topicOpResults) {
                  results.operators['topic-operator'] = topicOpResults;
                  hasResults = true;
                }

                // Parse user-operator results
                const userOpDir = path.join(latestDir, 'user-operator');
                const userOpResults = parseOperatorResults(userOpDir);
                if (userOpResults) {
                  results.operators['user-operator'] = userOpResults;
                  hasResults = true;
                }

                // Assume amd64 if not specified
                allResults['amd64'] = results;
              }
            }

            if (!hasResults) {
              core.setOutput('has_results', 'false');
              core.setOutput('summary', '_No performance results found_');
              core.setOutput('timestamp', '');
              return;
            }

            const summary = generateMarkdownSummary(allResults);

            core.setOutput('has_results', 'true');
            core.setOutput('summary', summary);
            core.setOutput('timestamp', commonTimestamp);

            core.info('Performance report generated successfully');

          } catch (error) {
            core.error(`Error generating performance report: ${error.message}`);
            core.setOutput('has_results', 'false');
            core.setOutput('summary', `_Error generating performance report: ${error.message}_`);
            core.setOutput('timestamp', '');
          }