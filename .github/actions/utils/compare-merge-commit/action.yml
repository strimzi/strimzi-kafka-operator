name: "Compare Merge Commit"
description: "Compare current merge commit sha with merge commit sha from build workflow"

inputs:
  # In Azure we use build ID of build pipeline to retrieve Strimzi artifacts
  # This can be achieved here as well, but after offline discussion we agreed we will try to use just commit sha
  # as each commit should have only one unique passed build. In case we will find it is not sufficient
  # we can easily add another input runId and skip find-build job and directly download artifact.
  # TODO - the comment can be removed once we agree it is sufficient for releases
  commitSha:
    description: "Commit sha of latest commit pushed to a branch from which merge-commit is created"
    required: true
  mergeCommitSha:
    description: "Commit sha of merge commit used by this workflow run"
    required: true
  waitForBuild:
    description: "Wait for build to complete if it's still running"
    required: false
    default: "true"
  maxWaitMinutes:
    description: "Maximum time to wait for build completion (in minutes)"
    required: false
    default: "60"

outputs:
  buildRunId:
    description: "The ID of the build workflow run (empty string if SHA mismatch)"
    value: ${{ steps.compare-sha.outputs.buildRunId }}
  buildStatus:
    description: "Status of the build workflow"
    value: ${{ steps.find-build.outputs.status }}
  buildMetadataSha:
    description: "The SHA from the build metadata artifact"
    value: ${{ steps.compare-sha.outputs.buildMetadataSha }}

runs:
  using: "composite"
  steps:
    - name: Find Build Workflow Run
      id: find-build
      uses: actions/github-script@v7
      env:
        INPUT_SHA: ${{ inputs.commitSha }}
        WAIT_FOR_BUILD: ${{ inputs.waitForBuild }}
        MAX_WAIT_MINUTES: ${{ inputs.maxWaitMinutes }}
      with:
        script: |
          const {owner, repo} = context.repo;
          const buildWorkflowName = 'build.yml';
          const sha = process.env.INPUT_SHA;
          const waitForBuild = process.env.WAIT_FOR_BUILD === 'true';
          const maxWaitMinutes = parseInt(process.env.MAX_WAIT_MINUTES);

          core.info(`üîç Looking for Build workflow run for commit: ${sha}`);

          const maxWaitSeconds = maxWaitMinutes * 60;
          const startTime = Date.now();

          // Function to find build run
          async function findBuildRun() {
            const runs = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: buildWorkflowName,
              head_sha: sha,
              per_page: 1
            });
            return runs.data.workflow_runs[0];
          }

          // Initial attempt to find build
          let buildRun = await findBuildRun();

          if (!buildRun) {
            if (waitForBuild) {
              core.info('‚è≥ No build found yet. Waiting for build workflow to start...');

              // Wait for build to appear
              while (!buildRun) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);

                if (elapsed >= maxWaitSeconds) {
                  core.setFailed(`‚ùå Timeout: No build workflow found after waiting ${maxWaitMinutes} minutes`);
                  core.setFailed(`Please ensure the Build workflow has been triggered for commit ${sha}`);
                  return;
                }

                core.info(`Waiting... (${elapsed}s elapsed, max: ${maxWaitSeconds}s)`);
                await new Promise(resolve => setTimeout(resolve, 30000)); // Sleep 30 seconds
                buildRun = await findBuildRun();
              }
            } else {
              core.setFailed(`‚ùå No build workflow run found for commit ${sha}`);
              core.setFailed('Please trigger the Build workflow first or enable waitForBuild');
              return;
            }
          }

          core.info(`‚úÖ Found Build workflow run: #${buildRun.id}`);
          core.info(`üìä Status: ${buildRun.status}, Conclusion: ${buildRun.conclusion}`);

          // Wait for build to complete if it's still running
          if (buildRun.status !== 'completed' && waitForBuild) {
            core.info('‚è≥ Build is still running. Waiting for completion...');

            while (buildRun.status !== 'completed') {
              const elapsed = Math.floor((Date.now() - startTime) / 1000);

              if (elapsed >= maxWaitSeconds) {
                core.setFailed(`‚ùå Timeout: Build did not complete within ${maxWaitMinutes} minutes`);
                core.setFailed(`Build run: ${context.serverUrl}/${owner}/${repo}/actions/runs/${buildRun.id}`);
                return;
              }

              core.info(`Build still running... (${elapsed}s elapsed, max: ${maxWaitSeconds}s)`);
              await new Promise(resolve => setTimeout(resolve, 60000)); // Sleep 60 seconds

              buildRun = await findBuildRun();
            }

            core.info(`‚úÖ Build completed with status: ${buildRun.conclusion}`);
          }

          // Check if build was successful
          if (buildRun.status === 'completed' && buildRun.conclusion !== 'success') {
            core.setFailed(`‚ùå Build workflow failed with conclusion: ${buildRun.conclusion}`);
            core.setFailed(`Build run: ${context.serverUrl}/${owner}/${repo}/actions/runs/${buildRun.id}`);
            return;
          }

          // Output results
          core.setOutput('run_id', buildRun.id.toString());
          core.setOutput('status', buildRun.status);
          core.setOutput('conclusion', buildRun.conclusion || '');

          core.info(`üéØ Build workflow run #${buildRun.id} is ready`);
          core.info(`Build URL: ${context.serverUrl}/${owner}/${repo}/actions/runs/${buildRun.id}`);

    - name: Download build metadata
      uses: actions/download-artifact@v4
      with:
        name: commit-sha.txt
        run-id: ${{ steps.find-build.outputs.run_id }}
        github-token: ${{ github.token }}
        path: .

    - name: Compare commit SHA
      id: compare-sha
      uses: actions/github-script@v7
      env:
        BUILD_RUN_ID: ${{ steps.find-build.outputs.run_id }}
        MERGE_COMMIT_SHA: ${{ inputs.mergeCommitSha }}
      with:
        script: |
          const fs = require('fs');
          const mergeCommitShaFileName = 'commit-sha.txt';
          const buildRunId = process.env.BUILD_RUN_ID;
          const mergeCommitSha = process.env.MERGE_COMMIT_SHA;

          let buildMetadataSha = '';

          // Read build metadata SHA from downloaded file
          if (fs.existsSync(mergeCommitShaFileName)) {
            buildMetadataSha = fs.readFileSync(mergeCommitShaFileName, 'utf8').trim();
            core.info(`Build metadata SHA: ${buildMetadataSha}`);
            core.info(`Current merge commit SHA: ${mergeCommitSha}`);

            if (buildMetadataSha === mergeCommitSha) {
              core.info('‚úÖ SHA match! Build artifacts are up to date.');
              core.setOutput('buildRunId', buildRunId);
              core.setOutput('buildMetadataSha', buildMetadataSha);
            } else {
              const mismatchMessage = [
                `‚ö†Ô∏è  SHA mismatch detected!`,
                `Build artifacts were created for commit: ${buildMetadataSha}.`,
                `Current merge commit is: ${mergeCommitSha}.`,
                `Workflow will build it's own images.`
              ].join('\n');
          
              core.warning(mismatchMessage);
              core.setOutput('buildRunId', '');
              core.setOutput('buildMetadataSha', buildMetadataSha);
            }
          } else {
            core.warning(`‚ö†Ô∏è  Build metadata not found. Workflow will build it's own images.`);
            core.setOutput('buildRunId', '');
            core.setOutput('buildMetadataSha', '');
          }